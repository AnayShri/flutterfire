// Autogenerated from Pigeon (v10.1.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// An enumeration of document change types.
enum DocumentChangeType {
  /// Indicates a new document was added to the set of documents matching the
  /// query.
  added,

  /// Indicates a document within the query was modified.
  modified,

  /// Indicates a document within the query was removed (either deleted or no
  /// longer matches the query.
  removed,
}

/// An enumeration of firestore source types.
enum Source {
  /// Causes Firestore to try to retrieve an up-to-date (server-retrieved) snapshot, but fall back to
  /// returning cached data if the server can't be reached.
  serverAndCache,

  /// Causes Firestore to avoid the cache, generating an error if the server cannot be reached. Note
  /// that the cache will still be updated if the server request succeeds. Also note that
  /// latency-compensation still takes effect, so any pending write operations will be visible in the
  /// returned data (merged into the server-provided data).
  server,

  /// Causes Firestore to immediately return a value from the cache, ignoring the server completely
  /// (implying that the returned value may be stale with respect to the value on the server). If
  /// there is no data in the cache to satisfy the `get` call,
  /// [DocumentReference.get] will throw a [FirebaseException] and
  /// [Query.get] will return an empty [QuerySnapshotPlatform] with no documents.
  cache,
}

enum ServerTimestampBehavior {
  /// Return null for [FieldValue.serverTimestamp()] values that have not yet
  none,

  /// Return local estimates for [FieldValue.serverTimestamp()] values that have not yet been set to their final value.
  estimate,

  /// Return the previous value for [FieldValue.serverTimestamp()] values that have not yet been set to their final value.
  previous,
}

class PigeonFirebaseSettings {
  PigeonFirebaseSettings({
    this.persistenceEnabled,
    this.host,
    this.sslEnabled,
    this.cacheSizeBytes,
    required this.ignoreUndefinedProperties,
  });

  bool? persistenceEnabled;

  String? host;

  bool? sslEnabled;

  int? cacheSizeBytes;

  bool ignoreUndefinedProperties;

  Object encode() {
    return <Object?>[
      persistenceEnabled,
      host,
      sslEnabled,
      cacheSizeBytes,
      ignoreUndefinedProperties,
    ];
  }

  static PigeonFirebaseSettings decode(Object result) {
    result as List<Object?>;
    return PigeonFirebaseSettings(
      persistenceEnabled: result[0] as bool?,
      host: result[1] as String?,
      sslEnabled: result[2] as bool?,
      cacheSizeBytes: result[3] as int?,
      ignoreUndefinedProperties: result[4]! as bool,
    );
  }
}

class PigeonFirebaseApp {
  PigeonFirebaseApp({
    required this.appName,
    required this.settings,
  });

  String appName;

  PigeonFirebaseSettings settings;

  Object encode() {
    return <Object?>[
      appName,
      settings.encode(),
    ];
  }

  static PigeonFirebaseApp decode(Object result) {
    result as List<Object?>;
    return PigeonFirebaseApp(
      appName: result[0]! as String,
      settings: PigeonFirebaseSettings.decode(result[1]! as List<Object?>),
    );
  }
}

class PigeonSnapshotMetadata {
  PigeonSnapshotMetadata({
    required this.hasPendingWrites,
    required this.isFromCache,
  });

  bool hasPendingWrites;

  bool isFromCache;

  Object encode() {
    return <Object?>[
      hasPendingWrites,
      isFromCache,
    ];
  }

  static PigeonSnapshotMetadata decode(Object result) {
    result as List<Object?>;
    return PigeonSnapshotMetadata(
      hasPendingWrites: result[0]! as bool,
      isFromCache: result[1]! as bool,
    );
  }
}

class PigeonDocumentSnapshot {
  PigeonDocumentSnapshot({
    required this.path,
    this.data,
    required this.metadata,
  });

  String path;

  Map<String?, Object?>? data;

  PigeonSnapshotMetadata metadata;

  Object encode() {
    return <Object?>[
      path,
      data,
      metadata.encode(),
    ];
  }

  static PigeonDocumentSnapshot decode(Object result) {
    result as List<Object?>;
    return PigeonDocumentSnapshot(
      path: result[0]! as String,
      data: (result[1] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
      metadata: PigeonSnapshotMetadata.decode(result[2]! as List<Object?>),
    );
  }
}

class PigeonDocumentChange {
  PigeonDocumentChange({
    required this.type,
    required this.document,
    required this.oldIndex,
    required this.newIndex,
  });

  DocumentChangeType type;

  PigeonDocumentSnapshot document;

  int oldIndex;

  int newIndex;

  Object encode() {
    return <Object?>[
      type.index,
      document.encode(),
      oldIndex,
      newIndex,
    ];
  }

  static PigeonDocumentChange decode(Object result) {
    result as List<Object?>;
    return PigeonDocumentChange(
      type: DocumentChangeType.values[result[0]! as int],
      document: PigeonDocumentSnapshot.decode(result[1]! as List<Object?>),
      oldIndex: result[2]! as int,
      newIndex: result[3]! as int,
    );
  }
}

class PigeonQuerySnapshot {
  PigeonQuerySnapshot({
    required this.documents,
    required this.documentChanges,
    required this.metadata,
  });

  List<PigeonDocumentSnapshot?> documents;

  List<PigeonDocumentChange?> documentChanges;

  PigeonSnapshotMetadata metadata;

  Object encode() {
    return <Object?>[
      documents,
      documentChanges,
      metadata.encode(),
    ];
  }

  static PigeonQuerySnapshot decode(Object result) {
    result as List<Object?>;
    return PigeonQuerySnapshot(
      documents: (result[0] as List<Object?>?)!.cast<PigeonDocumentSnapshot?>(),
      documentChanges:
          (result[1] as List<Object?>?)!.cast<PigeonDocumentChange?>(),
      metadata: PigeonSnapshotMetadata.decode(result[2]! as List<Object?>),
    );
  }
}

class PigeonGetOptions {
  PigeonGetOptions({
    required this.source,
    required this.serverTimestampBehavior,
  });

  Source source;

  ServerTimestampBehavior serverTimestampBehavior;

  Object encode() {
    return <Object?>[
      source.index,
      serverTimestampBehavior.index,
    ];
  }

  static PigeonGetOptions decode(Object result) {
    result as List<Object?>;
    return PigeonGetOptions(
      source: Source.values[result[0]! as int],
      serverTimestampBehavior:
          ServerTimestampBehavior.values[result[1]! as int],
    );
  }
}

class _FirebaseFirestoreHostApiCodec extends StandardMessageCodec {
  const _FirebaseFirestoreHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PigeonDocumentChange) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is PigeonDocumentSnapshot) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is PigeonDocumentSnapshot) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PigeonFirebaseApp) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is PigeonFirebaseSettings) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is PigeonGetOptions) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is PigeonQuerySnapshot) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is PigeonSnapshotMetadata) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return PigeonDocumentChange.decode(readValue(buffer)!);
      case 129:
        return PigeonDocumentSnapshot.decode(readValue(buffer)!);
      case 130:
        return PigeonDocumentSnapshot.decode(readValue(buffer)!);
      case 131:
        return PigeonFirebaseApp.decode(readValue(buffer)!);
      case 132:
        return PigeonFirebaseSettings.decode(readValue(buffer)!);
      case 133:
        return PigeonGetOptions.decode(readValue(buffer)!);
      case 134:
        return PigeonQuerySnapshot.decode(readValue(buffer)!);
      case 135:
        return PigeonSnapshotMetadata.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FirebaseFirestoreHostApi {
  /// Constructor for [FirebaseFirestoreHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FirebaseFirestoreHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _FirebaseFirestoreHostApiCodec();

  Future<String> loadBundle(
      PigeonFirebaseApp arg_app, Uint8List arg_bundle) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirebaseFirestoreHostApi.loadBundle', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_app, arg_bundle]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<PigeonQuerySnapshot> namedQueryGet(PigeonFirebaseApp arg_app,
      String arg_name, PigeonGetOptions arg_options) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirebaseFirestoreHostApi.namedQueryGet', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel
        .send(<Object?>[arg_app, arg_name, arg_options]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as PigeonQuerySnapshot?)!;
    }
  }

  Future<void> clearPersistence(PigeonFirebaseApp arg_app) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirebaseFirestoreHostApi.clearPersistence', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_app]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> disableNetwork(PigeonFirebaseApp arg_app) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirebaseFirestoreHostApi.disableNetwork', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_app]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> enableNetwork(PigeonFirebaseApp arg_app) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirebaseFirestoreHostApi.enableNetwork', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_app]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}
